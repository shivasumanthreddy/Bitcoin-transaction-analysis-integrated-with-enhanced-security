Proof deletion

The program was designed to generate proofs of preimages of sha256. The aim of this project is to delete safely data by the Bitcoin transactions. The only data in which we are interested in are the OP_RETURN content and the Coinbase field of the Coinbase transactions. We discussed the reasons for our choices in "Bitcoindom: Protecting Bitcoin from Illegal Pornography".

Since the generation and verification of a proof of knowledge of the preimage of a given digest is expensive in terms of time and memory consumption, and due to the fact that in a normal scenario we don't need to delete an entire transaction (which can weigh up to 1 megabyte), but only a restricted set of bytes, we decided to propose a solution in which the algorithm takes into account in a white box manner. 

When a user gives a transaction in input to proofdel.py to generate the proof, proofdel.py splits the transaction into blocks of 64 bytes each as described by the sha256 standard. For each block in which there is at least one modified byte, proofdel.py generates a proof file. All these files are passed to the verifier that is able to verify them and only if all proofs are correctly evaluated, it says that the proof is correct.

The generation of the proof is computed via the external tool Isekay (https://github.com/sikoba/isekai), we refer readers to the Isekay documentation for details on this tool and the installation guide. We note that our program currently works only on Linux systems.

Our tool proves the following statement:

Let x be the original transaction, y the bytes to remove by x and x' the resulting transaction obtained substituting byte 0 to the bytes in y. 
Let i be the intervals in which the bytes of c was deleted.
Let h0, h1, ..., h7 the input values to a single sha256 loop, and h0', h1', ..., h7' the output of a single sha256 loop.
Let S be the circuit that implements the single sha256 loop, it means, given 64 bytes encoded as a sha256 block, and the values h0, h1, ..., h7, computes h0', h1', ..., h7'.
Let f be a functions such that f(x', y, i) = x.

The statement is 
Give x', i, h0, h1, ..., h7, h0', h1', ..., h7', the prover knows y s.t. h0', h1', ..., h7':= S(h0, h1, ..., h7, f(x', y, i))



Our program is composed of different objects:

1) The execution folder coinbase that contains the scripts needed to invoke isekai: hashgeneratecircuit.sh internally used to generate the circuit, hashprover.sh internally used to generate the proof and hashverif.sh internally used to verify the proofs.

2) The description of the circuit to provide to Isekai. It is written in the files hash.h and hash.cpp. The file hash.h describes the structures that contain the public input, the private input and the output for the proof.
The Input structure contains:
	- an unsigned char array of 64 elements, it will contain a sha block of 64 bytes of the modified transaction;
	- 8 arrays of two unsigned int each, it will contain the 8 words of 4 bytes to give in input to the sha cycle generate the 8 words of 4 bytes in output for the 64 bytes of the modified transaction given in input;
	- two unsigned int arrays of 64 bytes, where the first array represents the starting point of the intervals deleted by the 64 current bytes of the original transaction to obtain the 64 bytes in input, the second array represents the final points of the intervals. To be more general we use always 64 couples internally, even if the real number of intervals is less then 64. All the starting and ending points of the intervals are at the beginning o the array, the other positions are padded with zeros.

The NzikInput structure contains only the deleted data of the current block of the transaction, that are contained in an unsigned char array of 64 bytes. Also in this case we use 64 to be more general, but only the set data will be used the other position will be ignored.

The Output structure contains an array of 8 unsigned int, these are the output words generated by a single sha cycle starting with the 64 bytes block of the transaction in input and the 8 arrays of two unsigned int each.

The file hash.cpp contains the description of the circuit, it means that it substitutes the deleted data in the input transaction and computes on it a single sha cycle.

3) Two python scripts sha.py and proofdel.py. 
The sha.py module is used by proofdel.py. It exposes the entire implementation of the sha256 algorithm in python and is used by proofdel.py to divide the input transaction into 64 bytes blocks and to compute the 8 words of four bytes each to give in input to a single sha cycle and the expected output.

The proofdel.py module contains al the procedures to read the transaction and interact with Isekai to generate the circuit, the proofs and to compute the verifications.
proofdel.py implements the following commands:
- W that is used to generate the .in file used by Isekay to generate the j1.in file needed to generate the proof. This file contains the public input and the witness that the prover will use to prove the statement.
- C that is used to generate the circuit.
- S that is the command that generates the j1.in file for the verifier. It is equivalent to the j1.in file used to generate the proof except that the witness field is removed.
- P that generates the proofs.
- V that verifies the proofs sent by the prover.


Installation guide
This tool requires that isekai is installed on the laptop. To install and configure isekai we refer to the isekay documentation.
This tool needs that python 3 is installed on the laptop. 
The tool will use only the os, sys and subprocess module, then no additional library has to be installed to run it.

The tool contains in the main folder the following data:
- the working directory coinbase;
- proofdel.py file;
- sha.py file;
- hash.cpp file;
- hash.h file;

The coinbase folder will be the working directory and contains the files 
- hashgeneratecircuit.sh in which the user needs to modify the path to hash.cpp and the path to the executable file of isekai;
- hashprover.sh in which the user needs to modify the path to  the executable file of isekai;
- hashverif.sh in which the user needs to modify the path to  the executable file of isekai;


Use guide

proofdel.py must be executed starting by the working directory coinbase (from now on every time we write working directory we mean the coinbase folder).

Let's describe in details all the commands.


W command

This command is used to generate the file .in, that will be used by isekai, for each 64 bytes block of the transaction that is modified. Since each .in file will have the same name, we generate them sequentially and name as soon as a file .in is generated we rename it adding at the end of the extension of the file the number of the block to which it refers starting from 0.
Assuming that the execution is done by the working directory and that the file structure of the tool is not changed, to invoke this command the command line is 

python3 ../proofdel.py W <intervals_num> <total_transaction_len> <del_data_len> <start end >*

(the order of the parameters is significant), where:
- intervals_num is the number of intervals of deleted data from the original transaction
- total_transaction_len represent the total number of bytes of the entire transaction. This number is used to read the data from the file containing the transaction
- del_data_len is the total number of bytes deleted by the original transaction and substituted with 0x00 in the modified transaction
- a list of start and end pairs. The i-th start value represents the starting point of the i-th interval in which the bytes are substituted with 0x00. The i-th end value represents the final point of the i-th interval in which the bytes are substituted with 0x00. Start and end values are computed starting by 0.

The command assumes that the working folder contains the files 'transaction' and 'original_tx.dat'. In 'original_tx.dat' the user should store the original transaction taken by the blockchain, while in 'transaction' the user should write the modified transaction, in which, for each byte to delete from 'original_tx.dat' it is substituted by the byte 0x00

This command produces a list of files hash.bc.in<i>, where the last i represent the related block. These files have the format required by isekai.


C command

This command is used to generate from the files hash.cpp and hash.h the file hash.j1 that describes the circuit, and a set of files hash.j1.in<i> that describe the inputs for the provers one for each block. Each file hash.j1.in<i> is computed starting from the hash.bc.in<i> generated with the W command.

Assuming that the execution is done by the working directory and that the file structure of the tool is not changed, to invoke this command the command line is 

python3 ../proofdel.py C <del_data_len>

(the order of the parameters is significant), where del_data_len is the total number of bytes deleted by the original transaction and substituted with 0x00 in the modified transaction

This command will produce:
- A set of files hash.j1.in<i>, one for each block for which the tool needs to generate the proof, where i is the number of the block starting from 0. These files will be generated sequentially since isekai will take the file hash.bc.in and produce a file hash.j1.in, then the tool will take each file hash.bc.in<i> from the folder, rename it and execute isekai, obtaining the file hash.j1.in. After this step rename the files hash.bc.in and hash.j1.in adding the number of the block at the end of the name.
- A file hash.j1 that contains the description of the circuit computed starting by hash.cpp and hash.h

Before executing this command is mandatory to invoke the command W.


S command

This command is used to generate the file hash.j1.in, that will be used by isekai, for each 64 bytes block of the transaction that is modified. This file will be used by the verifier, then is computed without the information related to the deleted data. This command will generate a set of files hash.j1.in<i>, one for each modified block and the verifier will manage these files to execute the verification process.

Assuming that the execution is done by the working directory and that the file structure of the tool is not changed, to invoke this command the command line is 

python3 ../proofdel.py S <intervals_num> <total_transaction_len> <start end >*

(the order of the parameters is significant), where:
- intervals_num is the number of intervals of deleted data from the original transaction
- total_transaction_len represent the total number of bytes of the entire transaction. This number is used to read the data from the file containing the transaction
- a list of start and end pairs. The i-th start value represents the starting point of the i-th interval in which the bytes are substituted with 0x00. The i-th end value represents the final point of the i-th interval in which the bytes are substituted with 0x00. Start and end values are computed starting by 0.

The command assumes that the working folder contains the files 'transaction' and 'digest'. In 'transaction' the user should write the modified transaction taken by the blockchain, while digest is a file computed by the prover with command P and should be passed to the verifier. The file digest contains 16 lines for each block for which proof was generated. The first 8 lines for each block contain the 32 bytes input value for the sha cycle, the last 8 lines contain the expected output of the computation of sha on the current block.

This command will produce a list of hash.j1.in<i> files that, differently from the hash.j1.in used by the prover do not contains any deleted data. These files have the format requested by isekai.

This command has to be executed by the verifier.


P command

This command generates the proofs to send to the verifier.

Assuming that the execution is done by the working directory and that the file structure of the tool is not changed, to invoke this command the command line is 

python3 ../proofdel.py P

No parameter is needed for this command.

The command assumes that the working folder contains the files hash.j1 and at least a file hash.j1.in<i>. For each file hash hash.j1.in<i> the tool rename the file in hash.j1.in and generate a proof file hashproof.p. After that a single proof for the block i is computed, the program renames the files hash hash.j1.in and hashproof.p adding at the end of the name the number i and continues for each modified block.

This command will produce a set of files hashproof.p<i>, one for each modified block and a file digest, that contains 16 lines for each block modified. The 16 lines represent the 8 input value to give to the sha cycle together with the block and the 8 output values produced by the single sha cycle.
This command can be executed only after the command C is executed.


V command

This command verifies all the proofs sent by the prover and if all these proofs are correct print a success string and return the value True.

Assuming that the execution is done by the working directory and that the file structure of the tool is not changed, to invoke this command the command line is 

python3 ../proofdel.py V <total_transaction_len> <orig_tx_hash>

(the order of the parameters is significant), where:
- total_transaction_len represent the total number of bytes of the entire transaction. This number is used to read the data from the file containing the transaction
- orig_tx_hash represent the SHA256 of the original transaction. This value is reported in the Bitcoin blockchain, or it must be shared with the verifier.


The command assumes that the working folder contains at least one file hashproof.p<i>, one file hash.j1.in<i> and one file digest<i>. For each proof in the folder, the tool renames appropriately the files and calls isekai to verify the proof. If all the verifications are successful and the digest correspond to the original digest, the verification step is considered successful.
The verification of the digest is computed as follow. For each modified block <i> the verifier takesthe input h0, h1,..., h7 and the output h0', h1', ..., h7' from the file digest<i>, where i starts from 0. For the remaining blocks the verifier has all the information to compute a single sha round. concatenating all the rouds, the verifier obtains the last h0', h1', ..., h7', on which the verifier compute the last sha operation to obtain the digest.

